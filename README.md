# Vernam Encryption
Substitution Ciphers is a very simple and primitive method for data encryption, where the plaintext is replaces with the ciphered text and can be decrypted by a specific decryption algorithm or a key, which only the receiver must know. The message to be encrypted is split into units like words, or pair of words or even letters, the receiver then performs inverse substitution to get back those units in order, when placed together form the original plain text.

The Vernam Cipher is based on the principle that each plaintext character from a message is 'mixed' with one character from a key stream.

The ciphertext is generated by applying the logical XOR operation (exclusive-or) to the individual bits of plaintext and the key stream. The advantage of using the XOR operation for this, is that it can be reverted, simply by carrying out the same operation again. In other words: 

```plaintext + key = ciphertext â‡’ ciphertext + key = plaintext```

In mathematics, the XOR operation is known as modulo-2 addition. In our case, the individual bits of the plaintext are XOR-ed with the individual bits of the key. The resulting bit will only be '1' if the two input bits are different. If they are equal (both 1 or both 0), the result will be '0'. 

# Assignment Solution

[CSC202A.pdf](CSC202A.pdf)

# Usage

To create the executable:
```
make
```

```
./vernamXOR
USAGE : ./vernamXOR -e <file to encrypt>
./vernamXOR -d <file to decrypt> <file key>
```

```
./vernamXOR -e message

VERNAM XOR ENCRYPTION - A Highly Secure One-Time Pad ----------------------------

DEBUG--*to_encrypt : The domestric is a small, typically furry, carnivorous mammal.
*

message is now Encrypted in message_encrypted, Key stored in message_key
```

Here the data to be encrypted is stored in a file named message and passed as an argument to the program, the program then takes the string stored in the file and performs vernam XOR for each and every character of the input, by generating a random character and then XORing this with the input, the random character generated is stores in the key, the Boolean value isEncrypted is not set to true since now the message is encrypted and then stores the key in message_key and the encrypted message is stored in message_encrypted. The relevant message is displayed.

```
./vernamXOR -d message_encrypted message_key

VERNAM XOR ENCRYPTION - A Highly Secure One-Time Pad ----------------------------

DEBUG--*myData -> message : The domestric is a small, typically furry, carnivorous mammal.
*

message_encrypted is now decrypted into file: message
```

Here the data to be encrypted is passed as a command line argument to the program along with the key file, it then reads both of these files and performs XOR operation of each and every character of the respective character of the input file to be decrypted and the key. The output is store in the Data Structure SecureData and the Boolean isEncrypted is set to false. The decrypted file is then saved into message_decrypted.

```
cat message
The domestric is a small, typically furry, carnivorous mammal.
```

# Algorithms

```
encrypt_algorithm:
Step 1: Start
Step 2: if mydata -> encrypted is true return -1
Step 3: if mydata is NULL return -1
Step 4: key <- malloc(length of mydata -> message * size of key)
Step 5: encrypted <- malloc(length of mydata -> message * size of key)
Step 6: declare i
Step 7: srand(time(0)) //seed rand with current system time
Step 8: while i < length of mydata -> message loop through Step 9 to Step 11
Step 9: key[i] = 65 + rand()%(CHAR_MAX - 65)
Step 10: encrypted[i] = mydata -> message[i] XOR key[i]
Step 11: i <- i + 1
Step 12: free(mydata -> message)
Step 13: mydata -> message = encrypted
Step 14: mydata -> is_encrypted = true
Step 15: Stop
```

```
decrypt_algorithm:
Step 1: Start
Step 2: if mydata -> encrypted is true return -1
Step 3: if mydata -> message is NULL return -1
Step 4: decrypted <- malloc(length of mydata -> message * size of decrypted)
Step 5: declare i
Step 6: while i < length of key loop through Step 7 to Step 8
Step 7: decrypted[i] = mydata -> message[i] XOR key[i]
Steo 8: i <- i + 1;
Step 9: free(mydata -> message)
Step 10: mydata -> message = decrypted
Step 11: mydata -> encrypted = false
Step 12: Stop
```
